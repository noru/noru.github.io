{"componentChunkName":"component---src-templates-post-tsx","path":"/blog/2019-12-16","webpackCompilationHash":"6a18dbb92efffbd676a9","result":{"data":{"markdownRemark":{"html":"<p>公司第一个(也是我的第一个)小程序今天上线了!</p>\n<img src=\"/assets/image/miniprogram.jpg\" width=150 height=150 />\n<p>总得来讲, 整个开发过程是一个吃 💩 吃到习惯, 到最后觉得再吃一点也还可以接受, 大概就是斯德哥尔摩综合症吧.</p>\n<p>在正式开始原生小程序开发之前, 还使用了好评较多的<a href=\"https://taro.jd.com/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">TaroJs</a>来开发 KYC 的 H5(这 tm 的发明的这个词...)App. 尽管 Taro 的工具链很完整有很紧跟潮流的使用了大部分流行技术, 还是避免不了各种坑要自己填. 总的来说, 流行框架带来的开发效率, 被填各端特有的坑所花的精力基本抹平, 甚至入不敷出也是有可能, 毕竟我只是在专注 H5 端开发的情况下就发现了很多问题. 要怎样做到在这样的平台下体现出多端同构的优势, 这是一个我无法回答的问题.</p>\n<p>鉴于需求上的变化(专注微信端), 小程序端正式启动时还是果断采用了原生的道路. 在上线后也顺便总结一下, 从零到一搭建一个能吃的下去的 💩 的过程.</p>\n<h2 id=\"用户是一等公民-但开发者不是\"><a href=\"#%E7%94%A8%E6%88%B7%E6%98%AF%E4%B8%80%E7%AD%89%E5%85%AC%E6%B0%91-%E4%BD%86%E5%BC%80%E5%8F%91%E8%80%85%E4%B8%8D%E6%98%AF\" aria-hidden=\"true\" class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>用户是一等公民, 但开发者不是</h2>\n<p>这是现在我全部的小程序开发体会. 可以看出微信为了把握住触达用户的这一关口, 基本上什么事都做得出来. 当然这本身没有什么错, 只是由于本身能力和思维方式的问题, 让开发者吃了太多的 💩.</p>\n<p>小程序原理上的设计, 借鉴了很多 web 标准,尤其是<a href=\"https://developer.mozilla.org/en-US/docs/Web/Web_Components\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Web Components</a>, 刚使用起来甚至有在使用 Vue/Polymer 的错觉. 并且抛开简单的配置及组件定义, 并没有特别的多的关于如果组织前端框架的意见, 这就给了开发者搭建脚手架的空间. 诸如 MobX 等流行的库在小程序中使用并无太大问题. 按理说, 整个小程序架构也算是出自见过世面的人之手.</p>\n<p>但是...</p>\n<ul>\n<li>是没用过<code class=\"language-text\">Promise</code>还是没见过<code class=\"language-text\">Node</code>的 callback? 整个<code class=\"language-text\">wxsdk</code>是基于自创的 callback 写法是什么意图?</li>\n<li>包管理这么重要的功能不好好屡屡清楚, 跑去做个什么 Wechat Devtools. 是觉得小程序的开发者都不配用命令行和 VSCode? 好不容易支持个<code class=\"language-text\">npm</code>, 那引入方式还不如自己写个脚本来的方便.</li>\n<li>API 说改就改. 社区问题基本不理.</li>\n<li>CICD 基本没法做, 因为要求 Devtools 处于登陆状态. API Secret 不香吗?</li>\n<li>调试工具难用到新层次. 控制台一堆莫名其妙的 warning.</li>\n<li>官方 ts 类型不改没法用</li>\n<li><code class=\"language-text\">Page</code>有存在的意义么</li>\n<li>各种<code class=\"language-text\">json</code>, 各种<code class=\"language-text\">../../../../</code></li>\n</ul>\n<p><strong>总之, 小程序的架构上在一些奇奇怪怪的地方用力过猛, 应该顺应标准的地方强行独树一帜, 对社区的一般实践和习惯视而不见. 搞的整个框架就像一曲农业重金属, 又华丽又土.</strong></p>\n<h2 id=\"任何东西重油重辣都能吃-即使是-\"><a href=\"#%E4%BB%BB%E4%BD%95%E4%B8%9C%E8%A5%BF%E9%87%8D%E6%B2%B9%E9%87%8D%E8%BE%A3%E9%83%BD%E8%83%BD%E5%90%83-%E5%8D%B3%E4%BD%BF%E6%98%AF-\" aria-hidden=\"true\" class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>任何东西重油重辣都能吃, 即使是 💩</h2>\n<p>除了莫名其妙且完全没必要的各种<code class=\"language-text\">.json</code>, 小程序的<code class=\"language-text\">模板</code> + <code class=\"language-text\">样式</code> + <code class=\"language-text\">控制器</code>的组织形式是老套且有效的. 从构建的角度看, 每一块都可以独立出来, 并且有完善的工具链支持. 已是过去式的<code class=\"language-text\">gulp</code>以及其各种插件就能够胜任小程序的各种现代化改造了.</p>\n<ul>\n<li>\n<p><code class=\"language-text\">.wxml</code> + <code class=\"language-text\">posthtml</code></p>\n<p>wxml 与 html 并无太大差异理论上无需改造直接导出即可使用. 但是由于小程序对体积的限制, 一些如图片之类的静态资源加载需要外链处理, 并且能够有类似<code class=\"language-text\">webpack</code>在<code class=\"language-text\">css</code>中 resolve 资源的能力. 因此引入了<code class=\"language-text\">posthtml</code>的<code class=\"language-text\">posthtml-urls</code>插件. 这一处理不要紧, 还引入了一些麻烦. 主要是<code class=\"language-text\">posthtml</code>会按照 html 规则解析<code class=\"language-text\">wxml</code>并重新输出, 导致一些<code class=\"language-text\">self-closing tag</code>和诸如<code class=\"language-text\">disabled</code>等特殊 attribute 无法正确输出. 好在通过插件配置都可以避免.</p>\n</li>\n<li>\n<p><code class=\"language-text\">.wxss</code> + <code class=\"language-text\">postcss</code></p>\n<p>wxss 在文档中被描述成<code class=\"language-text\">是css又不是css</code>的存在. 具体差别又语焉不详. 各种 css 特性处于薛定谔的猫状态, 到底能不能用谁也不知道. 好在<code class=\"language-text\">css variables</code>和<code class=\"language-text\">@import</code>是能够使用的, 再加上<code class=\"language-text\">sass</code>的<code class=\"language-text\">nested syntax</code>, 也可以说没有其他奢求了. 所以使用了<code class=\"language-text\">postcss-nested</code>, <code class=\"language-text\">postcss-assets</code>, <code class=\"language-text\">postcss-px2units</code>. <code class=\"language-text\">postcss-assets</code>与<code class=\"language-text\">posthtml-urls</code>作用相同, 用于处理 css 中的 assets 路径. <code class=\"language-text\">postcss-px2units</code>则用于把<code class=\"language-text\">px</code>转为<code class=\"language-text\">rpx</code>.</p>\n</li>\n<li>\n<p><code class=\"language-text\">.ts</code> to <code class=\"language-text\">.js</code></p>\n<p>这个便没什么好说了. <code class=\"language-text\">tsc</code>伺候即可, gulp 亦有相关插件. 值得注意点是由于小程序对<code class=\"language-text\">npm</code>的奇葩支持方式, 各<code class=\"language-text\">modules</code>在目标文件夹的<code class=\"language-text\">miniprogram_npm</code>中并且会更改文件夹结构. 这就为某些按路径引入模块埋下了一堆坑, 也就是说不能像平常一样愉快的使用<code class=\"language-text\">node_modules</code>. 这就注定了一切 npm 包的引入都得见招拆招的使用.</p>\n<p><code class=\"language-text\">Wechat DevTools</code>的<code class=\"language-text\">npm构建</code>也是跳不过的一关, 好在提供命令行接口, 但是依赖 DevTools 的安装路径. 小程序开发的缩影: 就是不喂你吃屎也要给你塞个苍蝇.</p>\n</li>\n<li>\n<p>其他: 复制 json, copy 或软链文件, ...</p>\n<p>常规操作, 不赘述. 状态管理方面, 由于 MobX 与小程序性格上匹配尚可, 配合官方插件使用起来也没什么好抱怨. 什么? 热更新? 想太多呵呵.</p>\n</li>\n</ul>\n<p>这样一系列<code class=\"language-text\">gulp task</code>下来, 配合开发工具的 watch 功能, 总体上能达到一个可接受的开发环境. <code class=\"language-text\">gulpfile.js</code>无需很繁琐, <code class=\"language-text\">package.json</code>也能保持清爽. 如果更进一步还可以封装成命令行工具. 不过, 何必呢...</p>\n<p>PS: 望这是我的最后一个小程序.</p>","fields":{"slug":"2019-12-16"},"frontmatter":{"title":"小程序从0到1总结","date":"16.12.2019","category":"Code","tags":["小程序","web","js"],"banner":"/assets/image/miniprogram.jpg"},"timeToRead":2}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"2019-12-16","prev":{"excerpt":"Talk is cheap, show me the   前言 听说到 scala.js 已经有一两年了吧。印象已经不深，只记得还在知乎上面劝别人不要用这个。当然，不是因为对scala本身有什么意见，而是这个东西剑走偏锋又脱离社区太远，必定不会是一个愉快的开发体验。 虽然这个偏负面的判断不是实践得来，却是合理甚至是必然的。  x   =  。这个套在 / 这一对好基友上面就是相互放大。反看 , 两个因数都是小于…","html":"<p><strong>Talk is cheap, show me the</strong> <a href=\"https://github.com/noru/snake\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"><img src=\"https://img.shields.io/github/forks/noru/snake.svg?label=Souce%20Code&#x26;style=social#nopreview\" alt=\"GitHub\"></a></p>\n<iframe src=\"https://blog.xiuz.hu/snake\" frameBorder=\"0\" width=\"100%\" height=\"500\" style=\"max-width:600px;margin-left:50%;transform:translateX(-50%);overflow:hidden;\"></iframe>\n<h2 id=\"前言\"><a href=\"#%E5%89%8D%E8%A8%80\" aria-hidden=\"true\" class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>前言</h2>\n<p>听说到<a href=\"https://www.scala-js.org/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">scala.js</a>已经有一两年了吧。印象已经不深，只记得还在知乎上面劝别人不要用这个。当然，不是因为对scala本身有什么意见，而是这个东西剑走偏锋又脱离社区太远，必定不会是一个愉快的开发体验。</p>\n<p>虽然这个偏负面的判断不是实践得来，却是合理甚至是必然的。<code class=\"language-text\">语言特性</code> x <code class=\"language-text\">社区资源</code> = <code class=\"language-text\">成功程度</code>。这个套在<code class=\"language-text\">ts</code>/<code class=\"language-text\">js</code>这一对好基友上面就是相互放大。反看<code class=\"language-text\">scala.js</code>, 两个因数都是小于1的，只能越乘越小。</p>\n<p>之所以现在又想做一些相关的摸索，是因为最近主要在使用<code class=\"language-text\">ts</code>做小程序的开发。小程序的社区资源相比web圈还是要缩水很多的，很多已经习惯的工具链在这里只能兜着用，手脚放不开。缺失了工具的情况下，很多代码中烦扰的问题就自然而然的寻求来自语言本身的解决方案。事实上在这种情况下，<code class=\"language-text\">ts</code>确实是且只是<code class=\"language-text\">js</code>的超集，并不能让人满意。举个例子，例如最能解决当前痛点的两个语言层面的功能当属<code class=\"language-text\">pattern matching</code>和<code class=\"language-text\">pipe operator</code>, 这两个<code class=\"language-text\">proposal</code>还都处于<code class=\"language-text\">stage1</code>状态，远水解不了近渴。更不要提诸如<code class=\"language-text\">immutable</code>之类。</p>\n<p>总结下来，有很多痛点都是主流的函数式编程语言已经解决了的。所以开始思考<code class=\"language-text\">FP compile to js</code>的方案。最先想到的当然是facebook的<code class=\"language-text\">ReasonML</code>，但是强制写分号让我迅速转到了下一个目标<code class=\"language-text\">fable</code>，希望能得到近似typescript的体验，结果并不能。<code class=\"language-text\">fable</code>一副老派<code class=\"language-text\">.Net</code>的作风，又是<code class=\"language-text\">.proj</code>又是安装dotnet又是visual studio又是NuGet的，虽然语言层面上很满意，但还是不太想下手。最后决定重拾scala，于是就有了现在这个项目。</p>\n<h2 id=\"搭建\"><a href=\"#%E6%90%AD%E5%BB%BA\" aria-hidden=\"true\" class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>搭建</h2>\n<p>脱离了<code class=\"language-text\">npm init</code>一把梭，真的是很不习惯。scala.js使用<code class=\"language-text\">sbt</code>作为构建工具，倒不是很陌生。JDK配置安装一条龙逃不掉的，紧接着maven下载包也要花上不少时间。总体来说还算可以接受。</p>\n<p>然而紧接着，就是扑面而来的来自JVM的问候：各种说着奇怪语言的报错和没有IDE就寸步难行的调试步骤。</p>\n<p>勉强熬过了所有错误，然后开始配置IDE。JVM上就认准Intellij错不了，但是那个速度在习惯了VS Code之后真的接受不了。还是配一下Scala的Language Server吧，官方推荐的<a href=\"https://scalameta.org/metals/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Metals</a>在vscode中竟然出人意料的简单，确实差不多<code class=\"language-text\">One Click Installation</code>，这个倒是我没有想到的。这个过程还吃到一个瓜：原本的主流Scala Lang Server <a href=\"https://ensime.github.io/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">ensime</a>和Metals之间的恩怨。</p>\n<p>Metals在补全和检查方面已经做到可以正常使用了，只是类型跳转，重命名等操作还是不灵。看来大场合还是要Intellij才行。</p>\n<h2 id=\"代码\"><a href=\"#%E4%BB%A3%E7%A0%81\" aria-hidden=\"true\" class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>代码</h2>\n<p>贪吃蛇从功能上讲，要比三消和（计划要写一个玩的）Pacman简单多了。DOM的渲染选择了<code class=\"language-text\">Scala.Binding</code>，一个敢叫板React的框架。由于只是简单做一下绑定和渲染，具体不评价。文档上面差强人意（易用性），但要解决的问题都找到了。个人觉得这个框架最多只做到了底层原理上的对标react，生产环境下的所必备的大部分功能肯定是缺失的，例如：路由，分包加载，状态管理。或者退一步讲，缺少成熟解决方案。</p>\n<p>最后大约<a href=\"https://github.com/noru/snake/blob/master/src/main/scala/snake/App.scala\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">100行多点</a>即完成了的游戏的功能，这里并没有追求行数，语法熟练或者刻意精简的话，我觉得50行甚至20行都不是问题。总结一下使用Scala写前端的体验。</p>\n<h3 id=\"优点\"><a href=\"#%E4%BC%98%E7%82%B9\" aria-hidden=\"true\" class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>优点</h3>\n<ul>\n<li>Scala支持Native XML，体验接近jsx</li>\n<li>Pattern Matching</li>\n<li>Case Class 简化声明，简化判等操作</li>\n<li>Scala强大的Collections</li>\n<li>Scala的各种语法糖</li>\n</ul>\n<h3 id=\"缺点\"><a href=\"#%E7%BC%BA%E7%82%B9\" aria-hidden=\"true\" class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>缺点</h3>\n<ul>\n<li>无法debug。这个可能是最严重的Show Stopper。前端很多debug方法诸如<code class=\"language-text\">console.log</code>和<code class=\"language-text\">debugger</code>之类全部无效。Source Map没看见过。这里不排除我已经生疏了的因素，但这方面肯定有问题。</li>\n<li>第三方库。尚未尝试其他js库交互，想必免不了一番折腾。猜测Scala的Dynamics功能会出场这一块。</li>\n<li>打包体积。100行的代码打包出来180kb。这之中自然包含了Scala语言包相关依赖，但是还是很可观。优化方案未知。</li>\n<li>依赖IDE。这其实不一定是缺点，强类型语言自然需要IDE配合才能体现优势。</li>\n<li>与其他资源的结合成疑。例如：inline css, 图片，字体等。这些资源现在scala中没有位置，需要直接对接html文件，跟webpack中的体验无法相比。</li>\n</ul>\n<h2 id=\"总结\"><a href=\"#%E6%80%BB%E7%BB%93\" aria-hidden=\"true\" class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>总结</h2>\n<p>从各方面来讲，scala.js都达不到我认为生产可用的标准。融入js环境的程度需要跟ts一样才有可能进一步作为，因为在语言的接受程度上就已经是劣势。ts现如今拥有最多的社区资源，最顺滑的开发体验，这已是scalajs不可能完成的任务了。</p>\n<p>返回来看初衷，也许ReasonML才是正确的选择，毕竟有react血统一致的优势，分号不分号的问题真是不值一提。后面会在摸索一下另外两种语言，说不定PacMan就用ReasonML来完成了。</p>","id":"358876d6-376d-5fd3-bee5-200462ca5ad8","fields":{"slug":"2019-12-08"},"frontmatter":{"date":"2019-12-08","title":"简单贪吃蛇游戏试水scala.js","category":"Code","tags":["game","web","js","scala"],"banner":"/assets/image/snake.png"},"timeToRead":2},"next":{"excerpt":"SEO 作为 Growth 团队的重要一环, 成了我现在对前端项目的主要优化方向. 除了一些常规内容(TDK, sitemap, robots.txt)的优化, 手头上的 一个 SPA 项目 也是工作重点: 这个项目信息多, 链接多, 是索引的重点. 那为什么不一开始就放弃 SPA 走 SSR? 原因是立项之初有此页面并不向公众开放, API 需要登录认证才可访问. 后续, API 随着策略调整放开了身份验证. 因此, SEO 的需求也就接踵而至. 对 SPA 的 SEO…","html":"<p>SEO 作为 Growth 团队的重要一环, 成了我现在对前端项目的主要优化方向. 除了一些常规内容(TDK, sitemap, robots.txt)的优化, 手头上的<a href=\"https://www.airwallex.com.cn/guides/payout\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">一个 SPA 项目</a>也是工作重点: 这个项目信息多, 链接多, 是索引的重点.</p>\n<p>那为什么不一开始就放弃 SPA 走 SSR? 原因是立项之初有此页面并不向公众开放, API 需要登录认证才可访问. 后续, API 随着策略调整放开了身份验证. 因此, SEO 的需求也就接踵而至.</p>\n<p>对 SPA 的 SEO 优化的常规解决方案, 就是在构建过程中加入截取<code class=\"language-text\">snapshot</code>的任务. 无论是<a href=\"https://github.com/geelen/react-snapshot\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">react-snapshot</a>还是<a href=\"https://github.com/markdalgleish/static-site-generator-webpack-plugin\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Webpeck 插件</a>还是<a href=\"https://github.com/stereobooster/react-snap/blob/master/doc/alternatives.md\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">其他什么方案</a>, 其原理都基本相同, 无非是采用无头浏览器渲染(prerendering)还是直接<code class=\"language-text\">renderToString()</code>(snapshoting)的区别. <a href=\"https://github.com/stereobooster/react-snap/blob/master/doc/alternatives.md#prerendering-snapshotting\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">两者优缺点</a>也很明显. 共同的问题就是, 对现有项目都有着多多少少的侵入性. 在亲自上手体验各个方案的过程中发生了非常多的幺蛾子, 让人很不愉快.</p>\n<p>所以打算自己动手实现一下这个项目的预渲染 + 后期优化. 当然还有一个策略是将整个项目迁移至 SSR 框架下, 虽然迁移本身并不一定是很大的工作了, 但考虑到随之而来的构建部署相关的影响...就不考虑了.</p>\n<h2 id=\"first-things-first\"><a href=\"#first-things-first\" aria-hidden=\"true\" class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>First things first...</h2>\n<p>项目本身不是纯静态页面, 而是链接 CMS 系统, 根据 API 返回数据渲染页面. 同时另一主要目标是侵入性减到最小. 由此, 选用无头浏览器(puppeteer)对一个路径列表进行爬取是比较合适的方案.</p>\n<p>这里直接用 node 写个简单的爬虫即可:</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token punctuation\">;</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">async</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> startDate <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Date</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">getTime</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n  <span class=\"token keyword\">const</span> total <span class=\"token operator\">=</span> PATHs<span class=\"token punctuation\">.</span>length\n  <span class=\"token keyword\">const</span> <span class=\"token constant\">USER_AGENT</span> <span class=\"token operator\">=</span> <span class=\"token string\">'Mozilla/5.0 (X11 Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/67.0.3239.108 Safari/537.36'</span>\n  <span class=\"token keyword\">const</span> browser <span class=\"token operator\">=</span> <span class=\"token keyword\">await</span> puppeteer<span class=\"token punctuation\">.</span><span class=\"token function\">launch</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n  <span class=\"token keyword\">const</span> pages <span class=\"token operator\">=</span> <span class=\"token keyword\">await</span> Promise<span class=\"token punctuation\">.</span><span class=\"token function\">all</span><span class=\"token punctuation\">(</span>Array<span class=\"token punctuation\">.</span><span class=\"token keyword\">from</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span> length<span class=\"token punctuation\">:</span> <span class=\"token number\">10</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">map</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> browser<span class=\"token punctuation\">.</span><span class=\"token function\">newPage</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n  <span class=\"token keyword\">let</span> runner <span class=\"token operator\">=</span> <span class=\"token keyword\">async</span> page <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>PATHs<span class=\"token punctuation\">.</span>length <span class=\"token operator\">></span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">await</span> <span class=\"token function\">RenderOnePage</span><span class=\"token punctuation\">(</span>PATHs<span class=\"token punctuation\">.</span><span class=\"token function\">pop</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> page<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token keyword\">await</span> Promise<span class=\"token punctuation\">.</span><span class=\"token function\">all</span><span class=\"token punctuation\">(</span>pages<span class=\"token punctuation\">.</span><span class=\"token function\">map</span><span class=\"token punctuation\">(</span>runner<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n  <span class=\"token keyword\">await</span> browser<span class=\"token punctuation\">.</span><span class=\"token function\">close</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token template-string\"><span class=\"token string\">`Total </span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span>total<span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token string\"> pages exported. Time elapsed </span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span>Math<span class=\"token punctuation\">.</span><span class=\"token function\">round</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">Date</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">getTime</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span> startDate<span class=\"token punctuation\">)</span> <span class=\"token operator\">/</span> <span class=\"token number\">1000</span><span class=\"token punctuation\">)</span><span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token string\">s`</span></span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>代码比较简单. <code class=\"language-text\">PATH</code>是项目中所有需要爬取的路径, 这里是 128 个国家*三个页面 + 两个功能页; <code class=\"language-text\">RenderOnePage()</code>即为使用<code class=\"language-text\">puppeteer</code>模拟<code class=\"language-text\">打开页面</code>-><code class=\"language-text\">访问网址</code>-><code class=\"language-text\">等待页面加载完成</code>-><code class=\"language-text\">操作DOM</code>-><code class=\"language-text\">输出html文件</code>的流程.</p>\n<p><code class=\"language-text\">操作DOM</code>的过程中, 根据页面内容动态添加了 TDK(title, description, keywords)元信息. 也可以做一些其他奇奇怪怪的事情(如下面介绍 👇).</p>\n<p>需要说明的是, 近 400 个网页每个 3 秒的时间爬取是个比较漫长的过程. 于是这里做了点优化: 模拟同时打开 10 个 tab 页进行抓取. 把整个抓取时间降到 120 秒左右.</p>\n<p>整个过程波澜不惊, 文件输出顺利. 剩下的过程就是把这些 html 文件上传至阿里云的 OSS, 然后再服务器端做一个简单的请求转发即可(注意区分 html 和其他 assets 即可).</p>\n<p>事情到这里其实已经完成了对 SPA 项目的基本 SEO 的需求.</p>\n<h2 id=\"but\"><a href=\"#but\" aria-hidden=\"true\" class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>But...</h2>\n<p>事情当然不可能那么简单. 虽然页面显示结果已经与正常网页无异, 但会出现:</p>\n<ul>\n<li>页面闪烁: 因为 react 会重新填充页面, 将已经预渲染的内容移除.</li>\n<li>首次访问中获取数据的 API 依然会被触发: 无疑浪费了预渲染的工作.</li>\n</ul>\n<p>第一个问题不容易察觉, 且容易解决. 因为<code class=\"language-text\">react-dom</code>为此专门提供<a href=\"https://reactjs.org/docs/react-dom.html#hydrate\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"><code class=\"language-text\">hydrate</code>方法</a>, 用之代替<code class=\"language-text\">render</code>即可. 简而言之, 此方法会尝试与 DOM 中已有的元素建立绑定关系(如, 事件), 而不是直接塞进新元素.</p>\n<p>第二个问题则麻烦一点, 由于 API 触发所带来的<code class=\"language-text\">loading</code>等效果, 使预渲染带来的首屏展示速度大打折扣. 解决这个问题取决于项目本身, 如果所有 API 触发都放在了组件生命周期方法中, 那恐怕神仙也救不了了. 但如果用了全局状态管理, 那这个问题就退化成一个如何初始化全局状态的问题了.</p>\n<p>在初始化全局状态问题之前, 如何获取预渲染中的数据是一个首先需要解决的问题. 这里我首先想到了<code class=\"language-text\">nextjs</code>的做法: 在 dom 中渲染一个不显示的节点存放序列化之后的数据. 不过即使没有用过 SSR 框架, 这也是一个自然而然的思路吧.</p>\n<p>对于<code class=\"language-text\">redux</code>和<code class=\"language-text\">mobx</code>, 初始化过程显而易见不赘述. 不巧的是这个项目使用的是<code class=\"language-text\">graphql</code>, 再折腾了半天<code class=\"language-text\">apollo client</code>如何写进初始值之后(文档真是差, 下次决定用 relay), 发现<code class=\"language-text\">Apollo client</code>提供了<a href=\"https://www.apollographql.com/docs/react/performance/server-side-rendering/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">SSR 解决方案</a>. 剩下的事情就简单了, 跟随文档, 用<code class=\"language-text\">client.extract()</code>输出序列化数据到 dom 上(注意要挂在 body 中可见元素后面), 并在创建 client 时利用<code class=\"language-text\">cache.restore</code>即可.</p>\n<p>至此经过测试, 页面的渲染已经完全不会有闪烁. 只是不知道为什么, 页面在有数据的情况下, 依然触发了一次 query. 怀疑是 cache 并未命中, 于是加了<code class=\"language-text\">id</code>和<code class=\"language-text\">__typename</code>等值, 依然没有做到避免这次触发. 不过鉴于这个问题对原本的问题影响基本可以忽略不计, 就不纠结了.</p>\n<h2 id=\"what-else\"><a href=\"#what-else\" aria-hidden=\"true\" class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>What else...</h2>\n<p>事情至此, 主要目标已经完成. 要完整实现工程化, 还需要将此过程集成到 CICD Pipeline 中. 构建过程仅仅依赖<code class=\"language-text\">puppeteer</code>和网络连接, 完全可以部署在函数计算服务中, 通过 CMS 系统的 Web hook 触发, 保证静态内容的更新. 整个过程做到全部自动化没有问题.</p>\n<p>需要注意的是, 函数计算服务对任务时间有上限限制, 所以若页面数量很多, 还需要进一步拆分任务. 另外 Aliyun 的函数计算还有 50M 的包体积限制(puppeteer 100M+), 需要发工单才行. 找到了理由偷懒, 于是, 再贱!</p>","id":"86868a02-e5b8-5dc8-82a9-75edd9f0c12a","fields":{"slug":"2019-12-27"},"frontmatter":{"date":"2019-12-27","title":"对单页应用(SPA)进行预渲染从而实现搜索引擎优化(SEO)","category":"Code","tags":["SPA","seo","web","js"],"banner":"/assets/image/seo.jpg"},"timeToRead":2}}}}